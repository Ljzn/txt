# 比特币：一种点对点电子现金系统

中本聪

简介： 一个完全点对点版本的电子现金可以使在线支付不再需要通过金融机构，二是直接从一方发送到另一方。数字签名解决了一部分问题，但是如果需要一个可信的第三方来防止双花，那么就丧失了它主要的好处。我们提出了一个使用点对点网络来解决双花问题的方案。这个网络会通过把交易哈希到一个基于哈希运算的工作量证明的持续的链上，来给交易打上时间戳，同时形成一个记录，这个记录只能通过重做工作量证明来修改。最长链不仅仅代表了事件记录，也证明了它是来自于最大的CPU算力池。只要大部分CPU算力被不愿意联合起来攻击网络，它们就会产生最长的链并淘汰攻击者。网络本身需要最小的结构。消息的广播是基于最大努力的，节点可以任意离开和重新加入网络，接受最大工作量证明的链作为他们离开时所发生的事情的证明。

1. 介绍

互联网上的商业活动极度的以来金融机构来作为可信的第三方处理电子支付。尽管对于绝大部分交易这个系统运转得很好，但由于这种基于信任的模型，系统有一些与生俱来的弱点，因为金融机构避免不了调解纠纷。调解的开销增加了交易成本，限制了最小可行的交易大小，断绝了小额交易的可能性，并且更深远的开销在于其丧失了为不可逆的服务提供不可逆的支付的能力。由于交易是可逆的，对于信任的需求扩大了。商家必须警惕他们的顾客，向他们索要更多的信息。接受那些固定比例的不可避免的欺诈。这些开销和支付不确定性可以通过使用实体货币来避免，但是没有商家会在一个没有可信的第三方担保的消息传递渠道上进行支付。

需要的是一个基于密码学证明的电子支付系统，而不是基于信任，使两方可以自愿地进行直接交易，而不需要可信的第三方。交易从计算复杂度上来看是不可逆的，这将保护卖家免受欺诈，常规的撤回机制可以被很容易地实现，来保护买家。在本论文中，我们提出了一个解决双花问题的方案，使用点对点分布式时间戳服务器来生成交易的完整顺序的计算量证明。只要诚实节点比任何攻击者的节点集团控制了更多的CPU算力，这个系统就是安全的。

2. 交易

我们这样定义一种电子硬币：一条由数字签名构成的链。硬币的拥有者是这样传递硬币的：对之前的交易的哈希以及下一个拥有者的公钥进行电子签名，并将其添加到链的末尾。收款人可以通过验证签名来验证所有权传递的链条。

问题在于，收款人不能验证硬币的拥有者之一是否已经把硬币双花了。通常的解决方法是引入可信权威机构或者是造币机构，来检查每笔交易是否被双花。每笔交易之后，币必须返回造币机构以发行一个新的币，并且只有造币机构直接发行的币是可以信任其未被双花的。这种方案的问题是整个货币系统都依赖运行造币机构的公司，每笔交易都必须通过他们，就像银行一样。

我们需要一种方式，来确保收款人能够知道前一个拥有者没有对任何更早的交易签过名。为了达到目的，只有最早的交易是被记录的，我们不在乎之后的双花企图。唯一能够确认交易存在的方法，是意识到所有的交易。在基于造币机构的模型中，造币机构能够意识到所有的交易并确定哪个最先到达。为了达到这个目的的同时不依赖一个可信机构，交易必须公开发布，并且我们需要这样一个系统：参与者认同一份单独的接收交易的顺序的记录。收款人在每笔交易的时候都需要证明，大部分的节点认同这笔交易是最早被接收到的。

3. 时间戳服务器

我们的方案从一个时间戳服务器开始。它是这样工作的：对一个包含元素的区块做哈希运算，为其打上时间戳，并且广泛地发布其哈希，类似于报纸或新闻组上的文章。时间戳能证明数据在那个时候已经存在，因为要得到数据的哈希值。每个时间戳都包含了之前的时间戳的哈希值，形成了一个链，每个新增的时间戳都加强了它之前的那一个。

4. 工作量证明

为了在点对点的基础上实现一个分布式时间戳服务器，我们会使用一个类似于Adam Back的Hashcash的工作量证明系统，而不是报纸或新闻报告。工作量证明涉及检查一个值的哈希，使用例如SHA-256的哈希算法，是否是以一定数量的0比特位开头的。平均的工作量难度，即所要求的0比特位的数目，是以指数增长的，并且可以通过进行一次哈希运算来验证。

对于我们的时间戳网络，我们是这样实现工作量证明的：增加一个区块中的nonce的值，直到获得一个值能够使区块的哈希符合0比特位数目的要求。一旦CPU算力的工作满足了工作量证明，这个区块就不能被更改，除非重做这些工作。当之后的区块链接上来后，修改区块所需的工作量就会包括该区块之后所有区块的工作量。

工作量证明也解决了另一个问题：在做选择时如何表示多数方。如果多数方是基于“一IP地址一票”，那么就可以被任何能够获取大量IP的人所颠覆。工作量证明必须是“一CPU一票”。多数方的决定是通过最长链来表示的，其具有最多的工作量投入。如果多数的CPU算力是由诚实节点控制的，那么诚实的链会最快地增长，并淘汰任何竞争链。为了修改一个过去的区块，攻击者需要：重做这个区块及其之后所有区块的工作量证明，追上并超过诚实节点的工作量。之后，我们将展示：在新的区块被添加的时候，一个更慢的攻击者追上的概率会指数级地降低。

为了平衡硬件速度的增加，以及运行节点的意愿的变化，工作量证明的难度是根据平均每小时出块的量来进行调整的。如果出块过快，难度会增加。

5. 网络

运行这个网络的步骤如下：

  1）新的交易被广播给所有节点。  
  2）每个节点把新的交易收集到一个区块里。  
  3）每个节点为它的区块寻找特定难度的工作量证明。  
  4）当一个节点找到了工作量证明，它将这个区块广播给所有节点。  
  5）节点在满足以下条件时接受区块：区块内所有交易都是合法且未被花费过的。  
  6）节点通过以下方式表达他们对区块的接受：使用其接受的区块的哈希值作为前一个区块的哈希，来在链上继续创造下一个区块。

节点总是把最长链认作正确的，并且会持续地扩展它。如果两个节点同时广播了不同版本的新区块，其它节点收到的先后顺序可能不同。在这时，他们会基于其先收到的区块做工作，但也保存另一个分支以备其变得更长。平局会在下一个工作量证明被找到的时候打破，一个分支会变得更长，在另一分支上工作的节点会切换到更长的分支。

新区块的广播并不是必须到达所有节点。只要它们到达了很多节点，不久之后它们就会被打包进区块。区块广播也可以容忍信息丢失。如果一个节点没有收到某个区块，当它收到下一个区块并且意识到它错过了一个时，它就会请求那个错过的区块。

6. 激励

按照设定，区块里的第一条交易是特殊的，它产生一个新的硬币，由这个区块的创造者所拥有。这是对节点们支持网络的激励，同时也提供了将硬币发行到流通领域的方式，因为没有一个中央的机构来发行它们。这种平稳增加货币量的机制是在模拟黄金的开采。在我们这里，消耗的是CPU时间和电力。

激励也可以是手续费。如果一个交易的输出值小于输入值，这个差值就是手续费，它会被计入交易所在的区块的奖励之中。一旦既定数量的硬币进入流通领域，激励可以完全由手续费组成，并且实现零通胀。

激励可以帮助节点保持诚实。如果一个贪婪的攻击者能够获取比诚实节点更多的CPU算力，他必须做出选择：是通过偷回他已经支付了的硬币来进行欺诈，还是使用这些算力产生新的硬币。他会发现按规则行事会更有利可图，这种规则会给他
比所有其他人更多的好处，比破坏这个系统来验证他自己的财富要更好。

7. 回收磁盘空间

一旦某个硬币的最新交易被足够的区块确认了，已花费掉的交易就可以被删除，以节约磁盘空间。为了达到目的的同时不破坏区块的哈希，交易是被哈希到一个默尔克树当中，区块哈希里只包含默克尔树的根。旧的区块可以通过去掉树枝来压缩。更细节的哈希不需要被存储。

一个不包含交易的区块头大约80字节。我们假设每10分钟生成一个区块，80字节*6*24*265 = 4.2MB每年。2008年销售的电脑通常是2GB的内存，而摩尔定律预测现在每年内存的增长是1.2GB，所以即使区块头必须保存在内存里，存储也不会是问题。

8. 简化支付验证

验证支付可以不需要运行一个全节点。用户只需要保存一份最长链的区块头的记录，这可以通过查询网络节点来获得，然后确认连接着这笔交易的默克尔树枝是在链上的。他不能自己检查交易，但是通过交易与链的连接，他可以看到节点接受了这笔交易，而且在网络广泛接受之后被打包进块了。

因此，只要诚实的节点控制着网络，这种验证就是可靠的，但当网络的攻击者处于上风时，这种方式的可靠性会变弱。尽管节点们可以自行验证交易，但简化的验证会被控制着网络的攻击者所制造的交易所欺骗。一种保护方案是接受警报，在节点发现非法的块的时候，提醒用户的软件下载完整区块，并检查被警告了的交易。那些想要频繁接受支付的商家，可能会为了更加独立的安全性和更快的验证，而运行自己的节点。

9. 价值的结合和分割

虽然可以将硬币单独地进行处理，但是在转账的时候单独发送每一分钱显得太笨重了。为了让价值可以被分割和结合，交易中包含多个输入和输出。通常，输入要么是之前的一笔更大的交易中的一个输出，要么是多个更小数额组合在一起，输出最多是两个：一个用于支付，一个用于找零（如果有找零的话，是返还给发送者）。

注意扇出（一个交易依赖多个交易，而且那些交易依赖更多的交易）在这里并不是一个问题。永远不会需要拆解出某个交易的完整历史。

10. 隐私

传统银行模型中某种程度上的隐私，是通过限制参与者获取信息的能力并且信任第三方来达到的。必须公开广播所有交易，使得这种方式变得不可行，但是隐私仍然可以通过公钥匿名来保障。公众可以看到某人给其他人发送了一笔钱，但是看不到这笔交易和任何人的关系。这和证券交易所的信息公开有些类似，在那里单个交易的时间和大小是公开的，即“纸带”，但是没有公开有谁参与了交易。

另一层防护是，每次交易都使用新的密钥对，这样就不会被联系到一个共同的拥有者。有些连接无法通过多个输入来避免，还是可以查到多个输入属于同一个拥有者。风险在于如果拥有者的个人信息被泄漏了，交易之间的连接会暴露它们输入同一个拥有者。

11. 计算

考虑一下这种情况：攻击者试图生成另一条比诚实的链更快的链。即使目标达到了，攻击者也不能对系统做任意的修改，比如凭空创造价或者获得从来不属于他的钱。节点不会接受非法的交易作为支付，而且诚实节点永远不会接受包含这种交易的块。攻击者只能试图拿回他最近花掉的钱，通过修改他自己的交易。

诚实链和攻击者链的竞争可以被看作是一个二项随机游走。成功情况是诚实链的长度加上一个块，领先程度加一，失败情况是攻击者链长度加上一个块，差距减一。

在给定的支出内，攻击者追上的概率可以用赌徒沉没问题来模拟。假设一个赌徒有无限的信用卡可以提供支出来让他无限尝试达到收支平衡。我们可以计算他达到收支平衡的概率，也就是攻击者追上诚实链的概率：

p = 诚实节点找到下一个区块的概率  
q = 攻击者找到下一个区块的概率  
q(Z) = 攻击者从落后Z个区块追上的概率  

q(Z) when p =< q -> 1
q(Z) when p > q  -> (q/p)^Z

当p>q时, 概率随着需要追上的块的数量变多，而指数级地下降。因此，如果攻击者没能在较早的时候幸运地得到跨越，那么他的机会将随着差距拉大而变得微乎其微。

我们现在考虑一下足够确定发出者不能再更改交易，需要等待多长时间。我们假设一个攻击者想让接收者相信他已经支付了，然后再把钱退回给自己。接收者会得到警报，但是攻击者希望那已经太迟了。

接受会在支付前生成新的密钥对，然后把公钥提供给发送者。这就避免了发送者事先准备好一条链的区块，然后在他足够幸运到可以获得足够领先的时候放出。一旦交易被发出，不诚实的发送者开始秘密地在一条平行的链上工作，这条链包含了他的交易的另一个版本。

接收者等待交易被打包进块，并且有Z个块连接到了后面。他不知道攻击者的工作进行到什么程度了，但假设诚实节点的每个块都花费了平均期望的时间，那么攻击者需要做的工作会是一个柏松分布：

lambda = Z*(q/p)

为了获得攻击者追上的概率，我们用他可能的工作进度的柏松密度乘上他从那个点追上的概率：

```c
#include <math.h>
double AttackerSuccessProbability(double q, int z)
{
  double p = 1.0 - q;
  double lambda = z * (q / p);
  double sum = 1.0;
  int i, k;
  for (k = 0; k <= z; k ++)
  {
    double poisson = exp(-lambda);
    for (i = 1; i <= k; i++)
      poisson * = lambda / i;
    sum -= poisson * (1 - pow(q / p, z - k));
  }
  return sum;
}
```

一些运行结果，我们可以看出可能性随着z在指数降低。

```
q=0.1
z=0 P=1.0000000
z=1 P=0.2045873
z=2 P=0.0509779
z=3 P=0.0131722
z=4 P=0.0034552
z=5 P=0.0009137
z=6 P=0.0002428
z=7 P=0.0000647
z=8 P=0.0000173
z=9 P=0.0000046
z=10 P=0.0000012
q=0.3
z=0 P=1.0000000
z=5 P=0.1773523
z=10 P=0.0416605
z=15 P=0.0101008
z=20 P=0.0024804
z=25 P=0.0006132
z=30 P=0.0001522
z=35 P=0.0000379
z=40 P=0.0000095
z=45 P=0.0000024
z=50 P=0.0000006
```

对于P小于0.1%...

```
P < 0.001
q=0.10 z=5
q=0.15 z=8
q=0.20 z=11
q=0.25 z=15
q=0.30 z=24
q=0.35 z=41
q=0.40 z=89
q=0.45 z=340
```

12. 总结

我们提出了一个不需要依赖信任的电子交易系统。我们从普通的数字签名构成的硬币框架开始，这提供了有力的所有权保障，但还缺少防止双花的机制。为了解决这个问题，我们提出了一个使用工作量证明的点对点的网络来公开地记录交易信息，这能使攻击者在诚实节点控制大多数CPU算力的情况下对网络进行攻击变得在计算难度上不可实践。这个网络因其非结构化的简洁而健壮。节点同时工作且只需要很少的协作。他们不需要身份验证，因为消息不需要被发送到一个特定的地点，而且只需要尽最大努力广播即可。节点可以任意地离开和重新加入网络，并接受工作量证明的链作为他们离开时所发生的事情的证明。它们使用CPU算力来进行投票，通过在某个块上继续工作来表现对于合法区块的接受，通过拒绝在某个块上继续工作来表达对非法区块的拒绝。所有必需的规则和奖励都可以通过这个共识机制来实施。
